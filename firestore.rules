rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ✅ HELPERS DE SEGURANÇA OTIMIZADOS
    
    function isAuth() {
      return request.auth != null;
    }

    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }

    function getRole() {
      return getUserData().role;
    }

    function isAdmin() {
      return isAuth() && getRole() == 'admin';
    }

    function isEditor() {
      return isAuth() && (getRole() == 'editor' || getRole() == 'admin');
    }

    function isOwner(userId) {
      return isAuth() && request.auth.uid == userId;
    }

    // ✅ NOVO: Verificador de Tenancy (Isolamento por Base/Projeto)
    function isAllowedBase(baseId) {
      let userData = getUserData();
      return isAuth() && (
        userData.role == 'admin' || 
        (userData.allowedBases is list && baseId in userData.allowedBases)
      );
    }

    function isSystem() {
      return isAuth() && request.auth.token.get('system', false) == true;
    }

    function canUpdateFinancialFields() {
      return isAdmin() || isSystem();
    }

    // Validação de tamanho de string
    function validString(field, minLen, maxLen) {
      return request.resource.data[field] is string &&
             request.resource.data[field].size() >= minLen &&
             request.resource.data[field].size() <= maxLen;
    }

    // Validação de email
    function validEmail(field) {
      return request.resource.data[field] is string &&
             request.resource.data[field].matches('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$');
    }

    // Validação de schema do Onboarding
    function validOnboarding() {
      let onboarding = request.resource.data.onboarding;
      return onboarding is map &&
             (!onboarding.keys().hasAny(['pipelineStatus']) || onboarding.pipelineStatus in ['new', 'waiting_apportionment', 'sent_to_apportionment', 'apportionment_done', 'waiting_compensation', 'invoiced']);
    }

    // ✅ REGRAS POR COLEÇÃO

    // CLIENTES: Validação estrita de schema e isolation
    match /clients/{clientId} {
      // Leitura: apenas usuários autenticados com acesso à base do cliente
      allow read: if isAuth() && (isAdmin() || isAllowedBase(resource.data.database));
      
      // Criação: apenas editores, com validação de schema e tenancy
      allow create: if isEditor() &&
        // Tenancy Check
        isAllowedBase(request.resource.data.database) &&
        // Campos obrigatórios
        request.resource.data.keys().hasAll(['name', 'createdAt', 'createdBy', 'status', 'database']) &&
        // Validações de tipo e tamanho
        validString('name', 1, 200) &&
        request.resource.data.status in ['active', 'inactive'] &&
        request.resource.data.createdBy == request.auth.uid &&
        request.resource.data.createdAt == request.time &&
        // Validação opcional de Onboarding
        (!request.resource.data.keys().hasAny(['onboarding']) || validOnboarding());

      // Atualização: apenas editores, campos limitados, sem mudar tenant
      allow update: if isEditor() &&
        isAllowedBase(resource.data.database) &&
        // Não pode mudar campos de auditoria ou tenancy
        !request.resource.data.diff(resource.data).affectedKeys().hasAny(['createdAt', 'createdBy', 'id', 'database']) &&
        // ✅ Hardening Financeiro: Protege campos críticos do Onboarding
        (
          !request.resource.data.diff(resource.data).affectedKeys().hasAny(['onboarding']) ||
          !request.resource.data.onboarding.diff(resource.data.get('onboarding', {})).affectedKeys().hasAny(['hasBeenInvoiced', 'firstInvoiceAt']) ||
          canUpdateFinancialFields()
        ) &&
        // Se onboarding mudar, valida schema
        (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['onboarding']) || validOnboarding());
      
      // Deleção: apenas admins
      allow delete: if isAdmin();
    }

    // TICKETS: Validação e isolamento
    match /tickets/{ticketId} {
      // Leitura: Verificação de tenancy
      allow read: if isAuth() && (isAdmin() || 
        // Se for collectionGroup, o filtro de database deve estar na query
        isAllowedBase(resource.data.database));
      
      // Criação: apenas editores
      allow create: if isEditor() &&
        isAllowedBase(request.resource.data.database) &&
        request.resource.data.keys().hasAll(['title', 'clientId', 'status', 'createdAt', 'createdBy', 'database']) &&
        exists(/databases/$(database)/documents/clients/$(request.resource.data.clientId));

      // Atualização
      allow update: if isEditor() &&
        isAllowedBase(resource.data.database) &&
        !request.resource.data.diff(resource.data).affectedKeys().hasAny(['createdAt', 'createdBy', 'clientId', 'id', 'database']);
      
      allow delete: if isAdmin();
    }

    // USUÁRIOS: Isolamento total
    match /users/{userId} {
      allow read: if isOwner(userId) || isAdmin();
      allow write: if false;
    }

    // BASES/PROJETOS
    match /bases/{baseId} {
      allow read: if isAllowedBase(baseId);
      allow write: if isAdmin();
    }

    // AUDIT LOGS: Append-only
    match /audit_logs/{logId} {
      allow read: if isAdmin();
      allow create: if isAuth() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if false;
    }

    // CONFIGURAÇÕES: Apenas admins
    match /settings/{settingId} {
      allow read: if isAuth();
      allow write: if isAdmin();
    }

    // FATURAS: Imutável
    match /invoices/{invoiceId} {
      allow read: if isAllowedBase(resource.data.database);
      allow write: if false;
    }

    // FALLBACK
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
